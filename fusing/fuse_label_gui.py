# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer


from pathlib import Path
import json
# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage, Frame, messagebox, simpledialog
from knowledge_graph import food_tree
import traceback
import os

def get_EXISTED_NODE(label_tree):
    # label_tree: hierarchical tree
    global EXISTED_NODE
    if label_tree:
        cur_level_keys = list(label_tree.keys())
        for cur_key in cur_level_keys:
            # 初始条件下，每一个节点的值都为自己，若后续多个节点合并，则节点值为合并前的多个节点数组
            # 注意，合并必须为叶子节点，不能合并非叶子节点
            EXISTED_NODE[cur_key] = [cur_key]
            get_EXISTED_NODE(label_tree[cur_key])
    else:
        pass

OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path(r".\build\assets\frame0")

# 加载已经标记好的结构树
TREE_FILE = r'./输入输出/tree.json'
with open(TREE_FILE, 'r', encoding='utf-8') as f:
    INFOS = json.load(f)
# 将已经标记好的食材进行汇总，用集合EXISTED_NODE表示，用于非重复标记判断
EXISTED_NODE = dict()  # 用于记录当前树中存在的最终节点，节点的值为当前节点所包含的原有食材名称
get_EXISTED_NODE(INFOS)
# 加载节点路径，用于记录原始节点和最终融合节点的映射关系，key为原始节点，value为最终节点
NODE_PATH_FILE = r'.\输入输出\node_path.json'
with open(NODE_PATH_FILE, 'r', encoding='utf-8') as f:
    NODE_PATH = json.load(f)
# 加载食材以及对应数量的文件，可视化食材时同时可视化数量
ALL_IN_FILE = r'.\输入输出\in_min5.json'
with open(ALL_IN_FILE, 'r', encoding='utf-8') as f:
    ALL_IN = json.load(f)
SELECT_NODE = dict()  # 用于表示拟删除的结构树节点，放入删除节点缓存区
CUR_LEVEL_KNOWLEDGE = []  # 用于表示结构树当前的级别
NUM_PER_ROW_CACHE = 3  # 用于表示缓存区每一行放多少个按钮快
CUR_TREE = food_tree(INFOS)  # 用于表示当前结构树
PAD_X, PAD_Y = 15, 6  # 用于表示每一个食材块间的间隔
INPUT_NODES = set()  # 用于标记用户自己创建的类别
SAVE_NODE_PATH_FILE = NODE_PATH_FILE  # 用于保存未标记的数据
SAVE_TREE_FILE = TREE_FILE  # 用于保存结构树
SAVE_IN_NUM = ALL_IN_FILE
# 上一步操作，每一个元素都是数组，每一个数组包含有添加的节点，以及删除的节点
# 在回撤步骤中，逐渐Pop最后一个数组，并删除添加的节点，添加已删除的节点
PRIOR_STEP = []

def relative_to_assets(path: str) -> Path:
    return ASSETS_PATH / Path(path)


def show_tree(keys: list):
    # visualize the food tree using labeled ingredient
    global CUR_LEVEL_KNOWLEDGE
    print(f"show level: {keys}")
    CUR_LEVEL_KNOWLEDGE = keys  # 记录当前所处树的层级，叶子节点层级不记录
    # 展示下一级数据时，将上一级数据清空
    for widget in entry_2.grid_slaves():
        widget.grid_forget()
    cur_dict = CUR_TREE.tree
    for key in keys:
        cur_dict = cur_dict[key]
    cur_level = list(cur_dict.keys())
    text_width = entry_2.winfo_width()
    cur_row = 0
    cur_column = 0
    cur_width = 0
    for i, name in enumerate(cur_level):
        node_num = '_' + str(ALL_IN[name]) if name in ALL_IN else ''
        button = Button(entry_2, text=name+node_num, command=lambda name=name: show_tree(keys + [name]))
        if cur_width + button.winfo_reqwidth() + PAD_X * 2 < text_width - 80:
            button.grid(row=cur_row, column=cur_column, padx=PAD_X, pady=PAD_Y)
            cur_width += button.winfo_reqwidth() + PAD_X * 2
        else:
            cur_row += 1
            cur_column = 0
            button.grid(row=cur_row, column=cur_column, padx=PAD_X, pady=PAD_Y)
            cur_width = button.winfo_reqwidth() + PAD_X * 2
        cur_column += 1


def next_tree():
    # visualize the next level ingredient
    cur_dict = CUR_TREE.tree
    for key in CUR_LEVEL_KNOWLEDGE:
        cur_dict = cur_dict[key]
    if cur_dict:
        show_tree(CUR_LEVEL_KNOWLEDGE + [list(cur_dict.keys())[0]])
    else:
        messagebox.showinfo("提示", "已经是食材树最低级别了")


def prior_tree():
    # visualize the prior level ingredient
    global CUR_LEVEL_KNOWLEDGE
    if CUR_LEVEL_KNOWLEDGE:
        CUR_LEVEL_KNOWLEDGE = CUR_LEVEL_KNOWLEDGE[:-1]
        show_tree(CUR_LEVEL_KNOWLEDGE)
    else:
        messagebox.showinfo("提示", "已经是食材树最高级别了")

def record_delete_multi_node(root, cur_path):
    global SELECT_NODE
    if root:  # 当前节点非空，表示仍有子节点
        cur_node_list = root.keys()
        for cur_node in cur_node_list:
            SELECT_NODE[cur_node] = cur_path
            print(f"将{cur_node}加入删除缓冲区")
            record_delete_multi_node(root[cur_node], cur_path + [cur_node])
    else:
        pass

def record_delete_node_cache():
    global SELECT_NODE
    if CUR_LEVEL_KNOWLEDGE[-1] in SELECT_NODE:
        log_txt = rf"{CUR_LEVEL_KNOWLEDGE[-1]}已经在删除节点缓存区，请勿重复添加"
        print(log_txt)
        messagebox.showinfo("提示", log_txt)
    else:
        cur_tree = CUR_TREE.tree
        for node in CUR_LEVEL_KNOWLEDGE:
            cur_tree = cur_tree[node]
        if cur_tree:  # 如果当前节点非叶子节点
            # result = messagebox.askyesno("Confirmation", f"{CUR_LEVEL_KNOWLEDGE[-1]}为非叶子节点\n"
            #                                                  "加入融合队列则默认将其所有子节点加入队列\n"
            #                                                  "请确认是否加入该节点")
            # if result:
            #     SELECT_NODE[CUR_LEVEL_KNOWLEDGE[-1]] = CUR_LEVEL_KNOWLEDGE[:-1]
            #     print(f"将{CUR_LEVEL_KNOWLEDGE[-1]}加入删除缓冲区")
            #     record_delete_multi_node(cur_tree, CUR_LEVEL_KNOWLEDGE)
            #     show_node_cache()
            # else:
            #     pass
            log_txt = rf"{CUR_LEVEL_KNOWLEDGE[-1]}非叶子节点，禁止直接融合"
            print(log_txt)
            messagebox.showinfo("提示", log_txt)
        else:
            SELECT_NODE[CUR_LEVEL_KNOWLEDGE[-1]] = CUR_LEVEL_KNOWLEDGE[:-1]
            print(f"将{CUR_LEVEL_KNOWLEDGE[-1]}加入删除缓冲区")
            show_node_cache()


def show_node_cache():
    global SELECT_NODE
    # 展示数据时，将上一次数据清空
    for widget in entry_1.grid_slaves():
        widget.grid_forget()
    for i, name in enumerate(SELECT_NODE.keys()):
        button = Button(entry_1, text=name, command=lambda name=name: delete_node_cache(name))
        button.grid(row=i // NUM_PER_ROW_CACHE, column=i % NUM_PER_ROW_CACHE, padx=PAD_X, pady=PAD_Y)


def delete_node_cache(delete_name):
    global SELECT_NODE
    del SELECT_NODE[delete_name]
    print(f"将{delete_name}移除删除节点缓冲区")
    show_node_cache()


def fuse_node():
    # 该函数通过SELECT_NODE变量来删除结构树节点
    global SELECT_NODE, EXISTED_NODE, PRIOR_STEP
    cur_step = {}  # 当前操作步骤
    if len(SELECT_NODE) >= 1:
        # 让用户创建融合后的新节点名称，名称不能为空！！
        # 弹出输入对话框
        user_input = simpledialog.askstring("Input", "请输入融合后的类别:")
        # 在后台接收用户输入
        if user_input:
            print("User input:", user_input)
            try:
                # 记录融合节点操作
                original_node = set()
                cur_step["del"] = []
                select_node_num = 0
                for node, path in SELECT_NODE.items():
                    CUR_TREE.delete_node(val=node, fathers=path)  # 在当前树中删除需要融合的节点
                    if node in ALL_IN:  # judge node is ingredient
                        cur_step["del"].append(
                            [node, path, EXISTED_NODE[node], ALL_IN[node]])  # 记录即将删除的节点，节点路径，该节点和原始节点的映射关系，节点食材数量
                        select_node_num += ALL_IN[node]  # 记录当前节点数量
                        del ALL_IN[node]  # 删除旧节点食材数量
                    else:
                        cur_step["del"].append(
                            [node, path, EXISTED_NODE[node], ''])

                    original_node.add(node)
                    for nn in EXISTED_NODE[node]:  # 如果用户多次融合相关节点，则需要嵌套挖掘最初节点
                        original_node.add(nn)

                    print(f"在结构树中删除{node}食材")
                    if node not in INPUT_NODES:
                        del EXISTED_NODE[node]  # 在记录当前树中存在的节点字典中删除需要融合的节点
                    else:
                        INPUT_NODES.remove(node)  # 如果为用户标记节点，则在标记节点集合中删除该节点
                if select_node_num > 0:
                    ALL_IN[user_input] = select_node_num  # 将节点对应数量进行更新
                    print(f"更新新节点数量:{ALL_IN[user_input]}")
                else:
                    print("the node is non ingredient node, cancel the num update")
                EXISTED_NODE[user_input] = list(original_node)

                try:
                    sign = CUR_TREE.add_node(val=user_input, fathers=CUR_LEVEL_KNOWLEDGE)
                    if sign:  # 如果成功加入结构树
                        cur_step["add"] = [user_input, CUR_LEVEL_KNOWLEDGE]  # 记录添加节点以及节点路径
                        # 记录已经标注好的标签，同时在所有未标注标签里删除该标签
                        INPUT_NODES.add(user_input)  # 将用户输入的节点记录
                        print(f"在结构树中加入新节点:{user_input}")
                    else:  # 如果用户输入的节点 在结构树中已存在，则不执行任何操作，只记录当前操作为空
                        cur_step["add"] = list()

                    # 至此，融合操作完成，初始化选择节点框，返回当前节点上一级，重新展示两个可视化
                    SELECT_NODE = dict()  # 初始化删除节点缓存
                    show_node_cache()
                    show_tree(keys=CUR_LEVEL_KNOWLEDGE)
                    # 记录当前融合操作过程
                    PRIOR_STEP.append(cur_step)
                except Exception as e:  # 如果添加用户输入节点报错
                    log_txt = f"A error was happened in input_node function\n: {traceback.format_exc()}"
                    print(log_txt)
                    messagebox.showinfo("提示", log_txt)

                    # # 需再次删除用户输入节点
                    # CUR_TREE.delete_node(val=user_input, fathers=CUR_LEVEL_KNOWLEDGE)
                    # # 记录已经标注好的标签，同时在所有未标注标签里删除该标签
                    # INPUT_NODES.add(user_input)  # 将用户输入的节点记录
                    for node, path in SELECT_NODE.items():
                        CUR_TREE.add_node(val=node, fathers=path)
                    SELECT_NODE = dict()  # 初始化删除节点缓存
                    show_node_cache()
                    show_tree(keys=CUR_LEVEL_KNOWLEDGE)
            except Exception as e:  # 如果删除旧节点出问题
                # 需要再次加入删除的节点
                for node, path in SELECT_NODE.items():
                    CUR_TREE.add_node(val=node, fathers=path)
                SELECT_NODE = dict()  # 初始化删除节点缓存
                show_node_cache()
                show_tree(keys=CUR_LEVEL_KNOWLEDGE)
                log_txt = f"A error was happened in delete_node function\n: {traceback.format_exc()}"
                print(log_txt)
                messagebox.showinfo("提示", log_txt)
        else:
            log_txt = f"输入节点名称不能为空!"
            print(log_txt)
            messagebox.showinfo("提示", log_txt)
    else:  # 如果融合候选框里没有节点
        messagebox.showinfo("提示", "请先选择至少1个叶子节点")

def back_step():
    global PRIOR_STEP, EXISTED_NODE
    if PRIOR_STEP:
        print("执行撤销操作一次，撤销操作过程如下：")
        prior_step = PRIOR_STEP.pop()
        # 将上一步删除的节点重新放入结构树，同时在融合节点与原始节点映射字典中还原对应关系
        # 将上一步添加的节点从结构树中删除，同时删除映射字典关系
        try:
            if prior_step["add"]:
                node, path = prior_step["add"]
                CUR_TREE.delete_node(val=node, fathers=path)
                del EXISTED_NODE[node]
                if node in ALL_IN:
                    del ALL_IN[node]
                print(f"删除已融合的节点:{node}")
        except Exception as e:
            log_txt = f"撤销时候删除融合节点报错，报错代码为:\n"
            print(log_txt)
            messagebox.showinfo("提示", log_txt+traceback.format_exc())
        try:
            for node, path, ori_node, in_num in prior_step["del"]:
                CUR_TREE.add_node(val=node, fathers=path)
                EXISTED_NODE[node] = ori_node
                if in_num != '':
                    ALL_IN[node] = in_num
                print(f"添加已删除的节点:{node}")
        except Exception as e:
            log_txt = f"还原旧节点时报错，报错代码为:\n"
            print(log_txt)
            messagebox.showinfo("提示", log_txt + traceback.format_exc())
        # 重新可视化
        show_tree(keys=CUR_LEVEL_KNOWLEDGE)
    else:
        log_txt = f"已经回撤到最后一步，无法继续回撤"
        print(log_txt)
        messagebox.showinfo("提示", log_txt)

def get_node_path():
    # 将EXISTED_NODE中的key, value倒置，转化为{原始节点:最终节点}的一一映射关系
    global NODE_PATH, EXISTED_NODE
    for node, original_node_list in EXISTED_NODE.items():
        for ori_nn in original_node_list:
            if ori_nn in NODE_PATH:
                NODE_PATH[ori_nn] = node

def save_file():
    # 随时保存标记好的数据
    # 将原始节点和最终的融合节点进行一一对应
    get_node_path()
    save_food_tree = CUR_TREE.tree  # 已经标注的食材字典
    with open(SAVE_TREE_FILE, 'w', encoding="utf-8") as f:
        json.dump(save_food_tree, f, ensure_ascii=False, indent=4)
    with open(SAVE_NODE_PATH_FILE, 'w', encoding='utf-8') as f:
        json.dump(NODE_PATH, f, ensure_ascii=False, indent=4)
    with open(SAVE_IN_NUM, 'w', encoding='utf-8') as f:
        json.dump(ALL_IN, f, ensure_ascii=False, indent=4)
    log_txt = "保存数据成功"
    print(log_txt)
    messagebox.showinfo("提示", log_txt)


if __name__ == "__main__":
    window = Tk()

    window.geometry("1080x645")
    window.configure(bg="#FFFFFF")

    canvas = Canvas(
        window,
        bg="#FFFFFF",
        height=645,
        width=1080,
        bd=0,
        highlightthickness=0,
        relief="ridge"
    )

    canvas.place(x=0, y=0)
    canvas.create_rectangle(
        29.0,
        90.0,
        1049.0,
        91.0,
        fill="#000000",
        outline="")

    canvas.create_rectangle(
        60.0,
        30.0,
        987.0,
        83.0,
        fill="#D74040",
        outline="")

    canvas.create_text(
        381.0,
        37.0,
        anchor="nw",
        text="食材数据融合V1.0",
        fill="#FFFFFF",
        font=("Inter", 32 * -1)
    )

    button_image_1 = PhotoImage(
        file=relative_to_assets("button_1.png"))
    button_1 = Button(
        image=button_image_1,
        borderwidth=0,
        highlightthickness=0,
        command=lambda: prior_tree(),
        relief="flat"
    )
    button_1.place(
        x=293.0,
        y=129.0,
        width=140.0,
        height=44.88038635253906
    )

    button_image_2 = PhotoImage(
        file=relative_to_assets("button_2.png"))
    button_2 = Button(
        image=button_image_2,
        borderwidth=0,
        highlightthickness=0,
        command=lambda: show_tree([]),
        relief="flat"
    )
    button_2.place(
        x=82.0,
        y=129.0,
        width=140.0,
        height=44.88038635253906
    )

    button_image_3 = PhotoImage(
        file=relative_to_assets("button_3.png"))
    button_3 = Button(
        image=button_image_3,
        borderwidth=0,
        highlightthickness=0,
        command=lambda: next_tree(),
        relief="flat"
    )
    button_3.place(
        x=492.0,
        y=129.0,
        width=140.0,
        height=44.88038635253906
    )

    entry_image_1 = PhotoImage(
        file=relative_to_assets("entry_1.png"))
    entry_bg_1 = canvas.create_image(
        880.0,
        389.0,
        image=entry_image_1
    )
    entry_1 = Text(
        bd=0,
        bg="#D9D9D9",
        fg="#000716",
        highlightthickness=0
    )
    entry_1.place(
        x=749.0,
        y=192.0,
        width=262.0,
        height=392.0
    )

    entry_image_2 = PhotoImage(
        file=relative_to_assets("entry_2.png"))
    entry_bg_2 = canvas.create_image(
        371.0,
        389.0,
        image=entry_image_2
    )
    entry_2 = Text(
        bd=0,
        bg="#D9D9D9",
        fg="#000716",
        highlightthickness=0
    )
    entry_2.place(
        x=13.0,
        y=192.0,
        width=716.0,
        height=392.0
    )

    button_image_4 = PhotoImage(
        file=relative_to_assets("button_4.png"))
    button_4 = Button(
        image=button_image_4,
        borderwidth=0,
        highlightthickness=0,
        command=lambda: record_delete_node_cache(),
        relief="flat"
    )
    button_4.place(
        x=773.0,
        y=129.0,
        width=213.0,
        height=45.0
    )

    button_image_5 = PhotoImage(
        file=relative_to_assets("button_5.png"))
    button_5 = Button(
        image=button_image_5,
        borderwidth=0,
        highlightthickness=0,
        command=lambda: fuse_node(),
        relief="flat"
    )
    button_5.place(
        x=1027.0,
        y=214.0,
        width=43.0,
        height=92.0
    )

    button_image_6 = PhotoImage(
        file=relative_to_assets("button_6.png"))
    button_6 = Button(
        image=button_image_6,
        borderwidth=0,
        highlightthickness=0,
        command=lambda: back_step(),
        relief="flat"
    )
    button_6.place(
        x=1027.0,
        y=322.0,
        width=43.0,
        height=92.0
    )

    button_image_7 = PhotoImage(
        file=relative_to_assets("button_7.png"))
    button_7 = Button(
        image=button_image_7,
        borderwidth=0,
        highlightthickness=0,
        command=lambda: save_file(),
        relief="flat"
    )
    button_7.place(
        x=1027.0,
        y=438.0,
        width=43.0,
        height=92.0
    )
    window.resizable(False, False)
    window.mainloop()

    save_file()




